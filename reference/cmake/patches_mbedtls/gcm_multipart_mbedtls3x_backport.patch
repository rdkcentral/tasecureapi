diff --git a/library/gcm.c b/library/gcm.c
index 2afe5025..a3be9068 100644
--- a/library/gcm.c
+++ b/library/gcm.c
@@ -392,9 +392,10 @@ int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
     int ret;
     unsigned char ectr[16];
     size_t i;
-    const unsigned char *p;
+    const unsigned char *p = input;
     unsigned char *out_p = output;
     size_t use_len, olen = 0;
+    size_t offset;
 
     GCM_VALIDATE_RET( ctx != NULL );
     GCM_VALIDATE_RET( length == 0 || input != NULL );
@@ -411,13 +412,51 @@ int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
         return( MBEDTLS_ERR_GCM_BAD_INPUT );
     }
 
+    /* Handle partial block from previous update call.
+     * This is the key fix from mbedTLS 3.x to support multi-part operations. */
+    offset = ctx->len % 16;
+    if( offset != 0 )
+    {
+        use_len = 16 - offset;
+        if( use_len > length )
+            use_len = length;
+
+        /* Get the current counter block (already computed in previous call) */
+        if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ectr,
+                                   &olen ) ) != 0 )
+        {
+            return( ret );
+        }
+
+        /* Continue filling the partial block WITHOUT incrementing counter */
+        for( i = 0; i < use_len; i++ )
+        {
+            if( ctx->mode == MBEDTLS_GCM_DECRYPT )
+                ctx->buf[offset + i] ^= p[i];
+            out_p[i] = ectr[offset + i] ^ p[i];
+            if( ctx->mode == MBEDTLS_GCM_ENCRYPT )
+                ctx->buf[offset + i] ^= out_p[i];
+        }
+
+        /* Only call gcm_mult when we complete a 16-byte block */
+        if( offset + use_len == 16 )
+        {
+            gcm_mult( ctx, ctx->buf, ctx->buf );
+        }
+
+        ctx->len += use_len;
+        length -= use_len;
+        p += use_len;
+        out_p += use_len;
+    }
+
+    /* Update total length for remaining data */
     ctx->len += length;
 
-    p = input;
-    while( length > 0 )
+    /* Process complete 16-byte blocks */
+    while( length >= 16 )
     {
-        use_len = ( length < 16 ) ? length : 16;
-
+        /* Increment counter ONCE per complete 16-byte block */
         for( i = 16; i > 12; i-- )
             if( ++ctx->y[i - 1] != 0 )
                 break;
@@ -428,7 +467,7 @@ int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
             return( ret );
         }
 
-        for( i = 0; i < use_len; i++ )
+        for( i = 0; i < 16; i++ )
         {
             if( ctx->mode == MBEDTLS_GCM_DECRYPT )
                 ctx->buf[i] ^= p[i];
@@ -439,9 +478,40 @@ int mbedtls_gcm_update( mbedtls_gcm_context *ctx,
 
         gcm_mult( ctx, ctx->buf, ctx->buf );
 
-        length -= use_len;
-        p += use_len;
-        out_p += use_len;
+        length -= 16;
+        p += 16;
+        out_p += 16;
+    }
+
+    /* Handle final partial block (less than 16 bytes).
+     * Increment counter but don't call gcm_mult yet - that will happen
+     * when the block is completed in the next update or in finish. */
+    if( length > 0 )
+    {
+        /* Increment counter for this new partial block */
+        for( i = 16; i > 12; i-- )
+            if( ++ctx->y[i - 1] != 0 )
+                break;
+
+        if( ( ret = mbedtls_cipher_update( &ctx->cipher_ctx, ctx->y, 16, ectr,
+                                   &olen ) ) != 0 )
+        {
+            return( ret );
+        }
+
+        /* Process the partial block */
+        for( i = 0; i < length; i++ )
+        {
+            if( ctx->mode == MBEDTLS_GCM_DECRYPT )
+                ctx->buf[i] ^= p[i];
+            out_p[i] = ectr[i] ^ p[i];
+            if( ctx->mode == MBEDTLS_GCM_ENCRYPT )
+                ctx->buf[i] ^= out_p[i];
+        }
+
+        /* Note: gcm_mult is NOT called here for partial blocks.
+         * It will be called when the block is completed in next update
+         * or in mbedtls_gcm_finish */
     }
 
     return( 0 );
@@ -465,6 +535,13 @@ int mbedtls_gcm_finish( mbedtls_gcm_context *ctx,
     if( tag_len > 16 || tag_len < 4 )
         return( MBEDTLS_ERR_GCM_BAD_INPUT );
 
+    /* Handle any remaining partial block from last update.
+     * This is part of the mbedTLS 3.x fix for multi-part operations. */
+    if( ctx->len % 16 != 0 )
+    {
+        gcm_mult( ctx, ctx->buf, ctx->buf );
+    }
+
     memcpy( tag, ctx->base_ectr, tag_len );
 
     if( orig_len || orig_add_len )
